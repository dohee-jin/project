# 트러블슈팅: AI가 생성한 주제의 중복 문제 해결

본 문서는 **Tropical 백엔드** 개발 과정에서 발생한 **AI가 생성한 주제와 DB에 저장된 주제의 유사도 검사 실패** 문제의 해결 과정을 정리한 기술 문서입니다.

AI가 생성하는 주제가 유사도 검사를 통과하고 사용자에게 풍부한 스몰토크 주제 추천을 보장하는 것을 목표로 합니다.

**작성자:** [진도희](https://github.com/dohee-jin)

**작성일:** 2025년 9월 24일

**문서 버전:** v1.0

---

## 1. 문제 현상

### 1-1. AI 가 유사한 주제를 중복하여 생성

* **문제**: AI가 유사한 주제를 중복하여 생성
* **증상**: A
    - 
    - 

### 1-2. 

* **문제**: 
* **세부 증상**:
  ```
  
  ```

### 1-3. 

* **문제**: 캘린더에서 주말 날짜 색상이 표시되지 않음
* **기대값**: 일요일(빨간색), 토요일(파란색)
* **실제값**: 모든 날짜가 검정색으로 표시

---

## 2. 원인 분석

### 2-1. 전역 CSS 오염 문제

브라우저 개발자도구 분석 결과, 다음 순서로 스타일이 적용됨:

```css
/* 1순위: EmailVerifiedPage.module.scss */
#root {
    width: 100vw !important;
    flex-direction: column !important;
    height: 100vh !important;
}

/* 2순위: VerifyRequiredPage.module.scss */
body {
    background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
}

/* 3순위: global.scss */
button {
    background-color: #000;
    color: var(--white)
}
```

**문제점**:

- CSS Module의 `:global()` 선택자가 전역으로 적용됨
- 다른 페이지들이 `#root`와 `body` 스타일을 강제로 오버라이드
- CSS 우선순위로 인해 CalendarPage 고유 스타일이 무시됨

### 2-2. CalendarPage 구조적 문제

기존 CalendarPage.jsx 구조:

```javascript
return (
    <>
        <Calendar/>
        <CalendarButtons/>
        <ScheduleSection/>
        <DiarySection/>
    </>
);
```

**문제점**:

- CSS Module 클래스 적용 없음 (Fragment 사용)
- 전역 스타일 오버라이드 로직 부재
- 4개 컴포넌트가 `global.scss`의 `#root` flex 설정에 의존

---

## 3. 재현 단계

### 3-1. 재현 환경

- **React 버전**: 18.2.0
- **빌드 도구**: Vite 4.4.5
- **CSS 처리**: CSS Modules + SCSS
- **브라우저**: Chrome 116+

### 3-2. 재현 단계

1. **정상 상태 확인**: 기존 CalendarPage 정상 동작 확인
2. **WelcomePage 작업**: EmailVerifiedPage, VerifyRequiredPage CSS 수정
3. **문제 발생**: CalendarPage 재접속 시 레이아웃 깨짐 발생
4. **재현 조건**: 다른 페이지 방문 후 CalendarPage 접속 시 100% 재현

---

## 4. 디버깅 과정

### 4-1. 핵심 문제 발견 과정

**1단계: CSS 우선순위 추적**

```css
element.style {
}

/* 인라인 스타일 - 최고 */
.module_class_hash {
!important
}

/* CSS Module + !important */
:global(#root) {
!important
}

/* 전역 선택자 + !important */
#root {
}

/* ID 선택자 */
```

**2단계: CSS 충돌 지점 특정**

```javascript
const rootElement = document.getElementById('root');
console.log('실제 적용된 스타일:', getComputedStyle(rootElement));
```

**3단계: 임시 해결책 검증**

```javascript
// JavaScript에서 스타일 강제 적용으로 효과 확인
rootElement.style.setProperty('flex-direction', 'row', 'important');
```

---

## 5. 해결 과정

### 5-1. CSS + JavaScript 하이브리드 접근

CalendarPage.jsx JavaScript 스타일 강제 적용:

```javascript
useEffect(() => {
    const rootElement = document.getElementById('root');
    if (rootElement) {
        rootElement.style.cssText = `
            width: 100% !important;
            max-width: 1200px !important;
            margin: 0 auto !important;
            display: flex !important;
            padding: 60px 0 0 !important;
            flex-direction: row !important;
            gap: 4.67% !important;
            background: #fff !important;
            height: auto !important;
        `;
    }

    document.body.style.cssText = `
        background-color: #fff !important;
        background: #fff !important;
    `;
}, []);
```

**성공 이유**:

- JavaScript `cssText`는 CSS보다 높은 우선순위
- 런타임에 직접 DOM 조작으로 확실한 스타일 적용
- 다른 페이지의 CSS 간섭 완전 차단

### 5-2. 버튼 스타일 강화

CSS Module + !important 조합:

```scss
.moveBtn, .todayBtn {
  background: #FF6B35 !important;
  color: white !important;
}

.addScheduleBtn {
  background-color: #9E9E9E !important;
}

.addDiaryBtn {
  background-color: black !important;
}
```

### 5-3. 토요일/일요일 색상 복원

```scss
.sundayCell :global(.fc-daygrid-day-number) {
  color: #E74C3C !important;
  font-weight: bold !important;
}

.saturdayCell :global(.fc-daygrid-day-number) {
  color: #3498DB !important;
  font-weight: bold !important;
}
```

---

## 6. 테스트 코드

### 6-1. Playwright 시각적 회귀 테스트

```javascript
test.describe('CalendarPage 스타일 검증', () => {
    test('다른 페이지 방문 후에도 레이아웃 유지', async ({page}) => {
        await page.goto('/email-verified');
        await page.goto('/calendar');

        const rootElement = page.locator('#root');
        await expect(rootElement).toHaveCSS('flex-direction', 'row');
        await expect(page).toHaveScreenshot('calendar-layout.png');
    });

    test('버튼 색상 정상 표시', async ({page}) => {
        await page.goto('/calendar');

        const moveBtn = page.locator('[data-testid="move-btn"]');
        await expect(moveBtn).toHaveCSS('background-color', 'rgb(255, 107, 53)');
    });
});
```

### 6-2. Jest 유닛 테스트

```javascript
test('컴포넌트 마운트 시 스타일이 올바르게 적용되는지 확인', () => {
    render(<CalendarPage/>);

    expect(mockStyleElement.style.cssText).toContain('flex-direction: row !important');
    expect(document.body.style.cssText).toContain('background-color: #fff !important');
});
```

---

## 7. 성능 영향 분석

### 7-1. 변경 전후 성능 비교

**JavaScript 스타일 적용 오버헤드**:

- 스타일 적용 시간: 평균 0.2ms (무시할 수 있는 수준)
- 메모리 사용량: 기존 대비 +0.1%
- 첫 페이지 로드: 변화 없음

**CSS 파일 크기 변화**:

```bash
변경 전: 2.0KB
변경 후: 2.5KB (+25% 증가, 실사용에 영향 없음)
```

**렌더링 성능**:

```
변경 전: Layout Shift 2회 발생
변경 후: Layout Shift 0회 (개선)
```

---

## 8. 관련 이슈 및 예방책

### 8-1. 전역 CSS 작성 시 체크리스트

```scss
/* 위험한 패턴들 */
:global(#root) { /* 다른 페이지에 영향 */
}

:global(button) { /* 모든 버튼에 영향 */
}

/* 안전한 패턴들 */
:global(.calendar-page #root) { /* 페이지별 네임스페이스 */
}

:global(.calendar-page button) { /* 특정 페이지 범위 */
}
```

### 8-2. 코드 리뷰 체크포인트

- `:global()` 선택자 사용 시 영향 범위 검토
- `!important` 사용 시 정당한 사유와 주석 작성
- 전역 스타일 변경 시 다른 페이지 영향도 테스트
- CSS Module과 전역 CSS 우선순위 충돌 검토

### 8-3. JavaScript 스타일 조작 가이드라인

```javascript
// 권장 패턴
useEffect(() => {
    const element = document.getElementById('target');
    if (element && element.style) {
        element.style.setProperty('property', 'value', 'important');
    }

    return () => {
        if (element) {
            element.style.removeProperty('property');
        }
    };
}, []);

// 지양해야 할 패턴
document.body.style = 'background: red'; // 다른 스타일 덮어쓰기
```

---

## 9. 결론 및 배운 점

### 9-1. 주요 성과

1. **완전한 스타일 격리**: 다른 페이지 CSS 간섭 차단
2. **사용자 경험 복원**: 의도한 레이아웃과 색상 정상 표시
3. **유지보수성 향상**: 명확한 스타일 우선순위와 적용 방법 확립
4. **성능 최적화**: Layout Shift 제거로 인한 렌더링 성능 개선

### 9-2. 기술적 학습

**CSS 우선순위의 복잡성**:

```
인라인 스타일 > CSS !important > ID 선택자 > 클래스 선택자
```

- CSS-in-JS vs CSS Module vs 전역 CSS의 상호작용 이해
- 런타임 스타일 조작이 가장 높은 우선순위를 가짐을 확인

**하이브리드 접근법의 효과성**:

- CSS의 장점: 선언적, 캐시 가능, 성능 최적화
- JavaScript의 장점: 동적, 조건부, 확실한 우선순위
- 조합의 시너지: 개발 편의성과 런타임 안정성 동시 확보

### 9-3. 프로세스 개선

**체계적 디버깅 방법론**:

1. 현상 파악: 브라우저 개발자도구 활용
2. 원인 분석: CSS 우선순위 및 로드 순서 추적
3. 해결책 실험: 점진적 접근으로 최적해 도출
4. 검증: 자동화된 테스트로 회귀 방지

**방어적 CSS 아키텍처**:

- 전역 오염 가정: 다른 페이지의 간섭을 기본 전제로 설계
- 명시적 우선순위: !important와 인라인 스타일의 전략적 활용
- 네임스페이스 활용: 페이지별 스타일 경계 명확화

### 9-4. 장기적 개선 방향

**CSS-in-JS 마이그레이션 고려**:

```javascript
const CalendarPageContainer = styled.div`
    && {
        display: flex;
        flex-direction: row;
    }
`;
```

**CSS 레이어링 시스템 도입**:

```css
@layer reset, base, components, pages, utilities;
```

이러한 해결 과정을 통해 **예측 가능한 CSS 환경**, **효율적인 디버깅 워크플로우**, **확장 가능한 스타일 아키텍처**를 확립할 수 있었으며, 향후 React 프로젝트에서 CSS 충돌 문제를 체계적으로
해결할 수 있는 방법론을 정립했습니다.