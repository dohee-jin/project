# 📅 2025-09-18

> **트로피칼** 프로젝트

## 🧭 오늘 작업한 주요 내용

* AI 스몰토크 주제 생성 기능 개발 (BE)
    * AI 요청 비즈니스 로직 작성 / 테스트
    * AI 모델 변경(Google Gemini -> Chat gpt)
    * DB 저장 파이프라인 구축

## 🚩 내일 작업할 내용

* AI 생성 주제 중복 처리 로직 추가

---

## ✅ AI 스몰토크 주제 생성 기능 개발 (BE)

* **AI 요청 비즈니스 로직 작성**
    * Spring AI ChatClient 사용을 위한 설정 파일 추가   
    AI 사용을 위해 스프링 컨테이너에 ChatClient Bean 등록 설정을 추가했다.   
    EmeddingModel은 Bean 등록을 따로 하지 않았는데 자동으로 주입된 것을 보면   
    스프링에서 spring ai 관련 Bean 들을 자동 구성하는 것으로 확인된다.
    ```AIConfig
    @Configuration
    public class AIConfig {

        @Bean
        public ChatClient chatClient(ChatClient.Builder builder) {
            return builder.build();
        }
    }
    ```

    * 사용자 활동 기반 AI 스몰토크 주제 생성 비즈니스 로직 v.1
    ```
    1. 사용자 회원가입/로그인 (SNS, 로컬 회원가입) 
        ↓
    2. 이용약관 동의 (개인정보를 AI에 전달하기 위해 필요)
        - 이용약관 동의 테이블에서 true로 선택한 부분만 DB 조회
        ↓
    3. 사용자 활동기록 기반 DTO 생성하여 AI에 전달
    - 활동기록 없으면 보편적 주제 제공
        ↓
    4. AI 프롬프트를 통해 주제 생성
    - 생성된 주제와 질문을 합쳐 임베딩 요청
        ↓
    5. 임베딩 유사도 검사 실행
    - DB 저장된 임베딩과 새롭게 생성된 임베딩의 유사도 검사
        ↓
    6. 유사도 검사를 통과한 5개의 주제만 추가로 DB에 저장
    ```
  
  * 비즈니스 로직에 따라 AI 요청 코드 작성 
    * 약관 동의 db 정보 조회    
    사용자별로 약관동의 항목이 다르기 때문에 다른 팀원이 약관 테이블 레포지토리에 만들어둔 아래 findAgreedOptionalConsentTypes(Long id) 로
    약관 동의 항목을 리스트로 받았다.

    ```
    List<UserConsent.ConsentType> agreeConsentList = userConsentRepository.findAgreedOptionalConsentTypes(userId);
    ```
    필수 동의 항목 - 일정   
    선택 동의 항목 - 일기, 투두리스트, 버킷리스트   
    선택 동의 항목에 대해서 true 인 약관 동의 항목들을 리스트로 반환해서 받았다. 
    본 프로젝트는 JPA와 QueryDsl를 활용하고 있어서 db 조회 시 결과가 없으면 빈 리스트로 반환하여 
    NPE 발생확률을 줄이고 코드 안정성을 높일 수 있다.

  * 동의한 약관 기반으로 사용자 활동기록 dto 만들기
    ```
    Map<SourceType, Supplier<List<ActivityDto>>> suppliers = Map.of(
    
    DIARY, () -> diaryRepository.findByUserIdAndDiaryDateBetween(userId, startDate, endDate)
    .stream()
    .map(diary -> new ActivityDto(diary.getId(), diary.getTitle(), diary.getContent(), diary.getCreatedAt()))
    .collect(Collectors.toList()),
    
    TODO, () -> todoRepository.findByUserAndDueDateBetween(user, startDate, endDate)
            .stream()
            .map(todo -> new ActivityDto(todo.getTodoId(), "", todo.getContent(), todo.getCreatedAt()))
            .collect(Collectors.toList()),

    BUCKET, () -> bucketListRepository.findByUserOrderByCreatedAtDesc(user)
            .stream()
            .map(bucket -> new ActivityDto(bucket.getBucketId(), "", bucket.getContent(), bucket.getCreatedAt()))
            .collect(Collectors.toList())
    );
    
    agreeConsentList.forEach(consent -> {
        Supplier<List<ActivityDto>> supplier = suppliers.get(mapConsentToSourceType(consent));
        if (supplier != null) {
            activities.put(mapConsentToSourceType(consent), supplier.get());
        }
    });
    
    // AI에게 요청을 보낼 최종 dto
    /*
    TopicGenerateRequest: {
        totalCount: 5,
        activities: {
        SCHEDULE: [
            {
            id: 1,
            content: "",
            createAt: 2025-09-18:~~~
            },
            {}
        ],
        TODO: [],
        DIARY: [],
        BUCKET: []
        }
    }
    */
    TopicGnerateRequest req = new TopicGenerateRequest(5, activities); 
    ```
    아래 코드는 약관 동의 enum과 SmallTalkSource enum을 맞춰주는 메소드이다.
    ```
    public SourceType mapConsentToSourceType(UserConsent.ConsentType consent) {
        return switch (consent) {
        case DIARY_PERSONALIZATION -> DIARY;
        case TODO_PERSONALIZATION -> TODO;
        case BUCKET_PERSONALIZATION -> BUCKET;
        default -> throw new RuntimeException("");
        };
        }
    ```
  db 조회해서 반환받은 리스트에서(빈 리스트일 경우 실행X) AI 요청을 보낼 ActivityDto 매핑을 진행했다.   
  ActivityDto 매핑 과정에서 switch-case 문 대신 Supplier 를 사용했다.

  **Supplier란?**:   
  자바8에 추가된 함수형 인터페이스   
  매개 변수를 어떠한 입력값도 받지 않고 결과를 반환하는 역할을 한다.   
  지연평가(Lazy Evaluation) 방식으로 미리 정의해두고 supplier.get() 호출 시점에 동작한다.  


  * **Supplier 도입으로 얻은 장점**
    * Supplier를 사용하여 약관동의 항목의 확장성을 높였다.
    * 지연 평가로 필요한 db만 조회하여 효율성을 높였다.
    * switch-case 문보다 짧은 코드로 가독성을 높였다.
    

* **AI 요청(Spring AI 사용)**  
  Spring AI의 강력한 추상화로 쉽게 AI에게 요청을 보내고 응답을 받을 수 있다.   
  Spring AI 버전에 따라 ChatClient -> ChatModel로 바뀌었으니 버전을 확인하고 코드를 작성해야한다.
  트로피칼 프로젝트에는 1.0.0-M5 버전을 사용했다.
  ```
  private final ChatClient chatClient;

  private String getTopic(TopicGenerateRequest req, Long userId) {

      사용자가 받은 스몰톡 주제가 있는지 확인
      List<String> topics = smalltalkTopicRepository.findSmalltalkTopicsByUserId(userId).stream()
              .map(topic -> topic.getTopicContent())
              .collect(Collectors.toList());

      USER_PROMPT = "";
      if(!topics.isEmpty()) {
          USER_PROMPT = "\n\n이미 추천된 주제는 다음과 같습니다: "
                  + topics
                  + "\n이 주제들은 추천하지 않고 새로운 주제로 제시해주세요.";
      }

      try {
          String response = chatClient
                  .prompt()
                  .system(SYSTEM_TEMPLATE) // 공통 프롬프트
                  .user(u -> u.text(req.toString() + USER_PROMPT)) // dto를 String으로 변환하여 AI 요청
                  .call()
                  .content();
          ;

          return response;

      } catch (Exception e) {
          throw new RuntimeException("주제 추천 중 오류 발생");
      }
  }
  ```
  chatClient는 생성자로 주입받아서 사용하면 된다.   
  아래는 Spring AI ChatClient의 메소드 체인이다.    
  * chatClient.prompt().system().user().call.content();
    * chatClient.prompt()
      - ChatClient의 프롬프트 빌더를 시작
      - 새로운 대화 요청을 구성하기 위한 진입점 역할이다.
    * system()
      - 시스템 메시지를 설정
      - AI 모델에게 역할이나 행동 방식을 지시하는 용도로 사용된다.
      - AI에게 공통으로 요청할 프롬프트 템플릿을 전달한다.
    * user()
      - 사용자 메시지를 설정
      - 실제 질문이나 요청 내용이 들어가는 부분이다.
      - 대화에서 사용자가 입력하는 내용에 해당한다.
    * call()
      - AI 요청
      - 지금까지 설정된 프롬프트(system + user)를 모델에 전달
      - 동기적으로 실행되며, 응답을 기다린다.
      - ChatResponse 객체를 응답한다.
    * content()
      - 모델의 응답에서 텍스트 내용만 추출
      - ChatResponse 객체에서 실제 생성된 텍스트만 String으로 반환한다.
    AI 응답 내용을 더 자세히 알고 싶으면 
    ```
    ChatResponse response = chatClient.prompt()
    .system()
    .user()
    .call(); 

    String content = response.getResult().getOutput().getContent();
    Usage usage = response.getMetadata().getUsage(); // 토큰 사용량 등
    ```
    .content() 사용 대신 getter를 사용하여 정보를 얻을 수 있다.


* **AI 모델 변경(Google Gemini -> Chat gpt)**     
  AI가 스몰토크 주제를 잘 생성하는지 테스트를 해보았는데 같은 프롬프트로 Gemini는 사용자와 AI간의 소통을 위한 스몰토크 주제를 추천했고
  Chat GPT는 사용자가 타인에게 사용할 수 있는 주제를 추천했기에 Gemini 에서 Chat gpt로 AI 모델을 변경했다.    
  Chat gpt는 유료 API로 https://platform.openai.com/docs/overview
  사이트에 접속하여 프로젝트를 생성하고 결제하여 사용할 수 있다.   

  
* **AI 생성 주제 DB 저장**  
  AI가 생성한 주제는 String 형태로 반환되므로 DB에 저장하려면 역직렬화가 필요하다.   
  ObjectMapper를 통해 데이터와 json의 직렬화 역직렬화를 할 수 있다.   
  **Jackson ObjectMapper**   
    Spring Boot를 사용하는 경우, spring-boot-starter-web 의존성을 추가하면 Jackson 라이브러리가 자동으로 포함되어 Json 처리 시 Jackson이 기본으로 사용된다.   
    별도의 의존성 설치는 필요하지 않다.
  ```String -> 객체 역직렬화
  List<AISmallTalkResponse> responses;
  
  try {
      responses = objectMapper.readValue(raw, new TypeReference<List<AISmallTalkResponse>>() {
      });
      
      // DB 저장, entity에 dto로 변환할 수 있는 편의 메소드를 만들었다.
      List<SmalltalkTopic> topics = responses.stream().map(
                       aiTopic -> SmalltalkTopic.toEntity(aiTopic, user)
               )
               .collect(Collectors.toList());

       smalltalkTopicRepository.saveAll(topics);
           
  } catch (JsonProcessingException e) {
      log.error("AI 응답 JSON 파싱 실패: {}", raw, e);
      throw new RuntimeException("Json 파싱 실패", e);
  }
  ```
  직렬화/역직렬화 시 예상치못한 에러가 발생할 수 있으므로 반드시 try-catch 문으로 감싸서 실행해야한다.
  readValue(1, 2) 는 첫번째 인자의 값을 두번째 인자의 형태로 반환한다.    
  이 때 List, Map, Set 같은 컨테이너 타입과 제너릭<>이 함께 사용되는 경우    
  objectMapper 혼자 처리가 불가능해 TypeReference로 정확한 타입을 지정해줘야 한다.   

---

## 💭 9/18 일 회고   
트로피칼 프로젝트에서 가장 중요한 AI 서비스 개발을 본격적으로 시작했다.
Spring AI 사용법을 막 배우게 되어 프로젝트에 바로 적용해 요청~저장 파이프라인을 빠르게 연결했다.
또한, 동일한 프롬프트라도 모델마다 의도 해석이 꽤 달라, “누구를 위한 주제인가”를 명확히 정의하는 게 중요하다는 걸 체감했다.
