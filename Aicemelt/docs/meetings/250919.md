# 📅 2025-09-19

> **트로피칼** 프로젝트

## 🧭 오늘 작업한 주요 내용

* AI 스몰토크 주제 생성 기능 개발 (BE)
  * AI 생성 주제 중복 처리 로직 추가

## 🚩 내일 작업할 내용

* AI 생성 주제 중복 처리 로직 수정
* 스몰토크 프론트엔드 기능 개발 

---

## ✅ AI 스몰토크 주제 생성 기능 개발 (BE) 
AI 생성 스몰토크 주제 중복 방지 로직은 아래 문서에 자세하게 기록했다.    
https://github.com/Aicemelt/Tropical-docs/blob/main/02_Architecture/AI_DuplicatePrevention_Guide.md

* **AI 생성 주제 중복 처리 로직 추가**   
  사용자의 활동기록을 기반으로 AI가 스몰토크 주제를 생성하는데 중복된 주제를 반환하면 사용자의 경험이 단조롭게 느껴질 수 있으므로, DB 저장 전 중복 여부를 검사하고 이미 존재하는 주제는 필터링하여 새로운 주제만 제공하도록 로직을 개선한다. 또한, 유사도 검사를 활용하여 의미적으로 동일한 주제를 판별하고, 일정 기준 이상의 유사도일 경우 중복으로 간주하여 제외한다.   

  중복 처리는 문장 유사도 검사를 통해 이루어졌으며 코사인 유사도를 통해 진행했다.   
  
  **코사인 유사도:** 두 벡터 사이의 각도 기반 유사도 계산
    * 벡터 크기에 영향을 받지 않고 의미적 유사도 측정 가능
    * 주제 내용이 길거나 짧아도 상대적 의미 비교 가능
    * 중복 방지 로직에서 새 주제와 기존 주제의 의미적 차이 판단에 핵심
    
  코사인 유사도를 계산하기 위해서 각 문장의 백터값이 필요하여 AI에게 주제 생성시 embeddind 값을 계산해서 주제를 반환할 수 있게 요청했다.   
  프롬프트에 아래 내용 추가을 추가하여 생성 주제에 대한 임베딩을 받아왔다.
  ```
   10. **임베딩 추가**: 각 주제(topicContent)에 대한 임베딩 벡터를 embedding 배열로 포함

   ....
   {
      "topicType": "COMPLEX",
      "topicContent": "헬스장 운동과 영어 학습 병행",
      "exampleQuestion": "운동과 공부를 병행할 때 어떤 방법을 사용하시나요?",
      "embedding": [0.12, 0.34, 0.56, ...],
      "sources": [
          { "sourceType": "SCHEDULE", "sourceId": 123 },
          { "sourceType": "TODO", "sourceId": 456 }
      ]
    },
  ```
  생성된 주제를 임베딩과 함께 db에 저장했다.
  임베딩 값은 String 으로 db에 저장했다. 임베딩 값의 db 저장 과정은 아래와 같다.
  ```
  AI 응답 
  ↓
  objectMapper.readValue(Json -> 객체) 역직렬화 
  ↓ 
  List<Double> 형태
  ↓
  writeValueAsString(DB에 저장하기 위해 문자열로 직렬화)
  ↓ 
  DB저장
  ```
  ```
  try {
    List<AISmallTalkResponse> responses = objectMapper.readValue(rawResponse, new TypeReference<List<AISmallTalkResponse>>() {
    });

    log.info("json parse log: {}", responses);
    List<SmalltalkTopic> topics = responses.stream().map(
                    aiTopic ->{
                        String embedding;
                        try {
                            embedding = objectMapper.writeValueAsString(aiTopic.embedding());
                        } catch (Exception e) {
                            throw new RuntimeException("embedding json 변환 실패");
                        }
                        return SmalltalkTopic.toEntity(aiTopic, user, embedding);
                    }

            )
            .collect(Collectors.toList());

    smalltalkTopicRepository.saveAll(topics);

  } catch (Exception e) {
      throw new RuntimeException("json 파싱 실패");
  }
  ```
  임베딩 값은 아래처럼 db에 저장된다.
  | created_at                | id | user_id | topic_type | topic_content           | embedding                     | example_question                 |
  |----------------------------|----|---------|------------|-------------------------|--------------------------------|----------------------------------|
  | 2025-09-23 16:32:04.575485 | 1  | 1       | LIFESTYLE  | 최근 특별했던 하루의 순간 | [0.03, -0.12, 0.25, ...]       | 최근 기억에 남는 하루가 있으신가요? |
  | 2025-09-23 16:32:04.590225 | 2  | 1       | DAILY      | 오늘의 일정과 소소한 계획 | [0.63, 0.15, -0.07, ...]       | 오늘 특별한 일정이 있으신가요?     |
  
  db에 저장된 데이터의 모습을 보면 임베딩 값이 한 칼럼에 리스트로 여러값이 들어가고 있어 1정규화를 위반하고 있다.   
  그러나 임베딩을 분리하여 별도 테이블로 관리할 경우 조회 시 성능 저하가 발생할 수 있어 한 칼럼에 직렬화된 문자열 형태로 저장했고    
  유사도 검사 로직에서 임베딩을 다시 파싱하여 백터 형태로 복원하여 활용했다.
  ```
  List<Double> storedList = objectMapper.readValue(topic.getEmbedding(), new TypeReference<List<Double>>() {});
  double[] storedEmbedding = storedList.stream().mapToDouble(Double::doubleValue).toArray();
  ```

* **코사인 유사도를 통한 문장 중복 검사**
  ```
  private double cosineSimilarity(double[] vectorA, double[] vectorB) {
    if (vectorA == null || vectorB == null) {
        throw new IllegalArgumentException("Vectors cannot be null");
    }
    if (vectorA.length != vectorB.length) {
        throw new IllegalArgumentException("Vectors must have the same length");
    }

    double dotProduct = 0.0;
    double normA = 0.0;
    double normB = 0.0;
    for (int i = 0; i < vectorA.length; i++) {
        dotProduct += vectorA[i] * vectorB[i];
        normA += vectorA[i] * vectorA[i];
        normB += vectorB[i] * vectorB[i];
    }

    double denominator = Math.sqrt(normA) * Math.sqrt(normB);
    if (denominator == 0.0) {
        return 0.0; // 제로 벡터 처리
    }
    return dotProduct / denominator;
  }
  ```
  ```
  double sim = cosineSimilarity(newEmbedding, storedEmbedding);

  // 코사인 유사도 계산
  if(sim >= threshold) {
      isSimilar = true;
      log.info("유사한 주제 발견 - 저장 안함: {} (유사도: {:.3f})", response.topicContent(), sim);
      break;
  }
  ```
  코사인 검사 메소드에서 반환한 유사도가 임계값보다 높을 경우 유사한 주제로 판단하여 DB에 저장하지 않는다. 임계값이 낮은 주제들은 유사도 검사를 통과하여 
  최대 5개까지 db에 저장된다.

* **채팅 모델이 생성한 임베딩 값의 신뢰성 문제 발생**   
유사도 검사를 통해 중복된 주제를 필터링하려고 했으나 AI가 생성한 주제들이 유사도 검사를 통과하지 못하여 DB에 저장되지 않는 문제가 발생했다.      
**문제 해결을 위한 아이디어**: 
  1. 키워드를 추출하여 비교 -> 중복 주제를 확인 -> 통과: db 저장 
  2. 임베딩의 길이를 소수점 5자리로 늘려 정확하게 비교
---

## 💭 9/19 일 회고   
스몰토크 생성과 DB 저장까지 확인한 뒤, 중복 주제 추천 방지 로직을 작성했다. 프롬프트에서 유사한 주제를 제한하려 했으나, 의미가 같은 문장이 여전히 생성되었다. 의미 기반 유사도 검사를 위해 임베딩 벡터를 사용해 코사인 유사도를 적용하려 했지만, 채팅 모델이 반환한 임베딩 값은 의미와 상관없이 유사하게 나오는 것을 확인했다. 임계값 조정도 효과가 없었고, 결국 채팅 모델 임베딩은 정확하지 않아 로직을 임베딩 모델 기반으로 수정해야 한다는 결론을 얻었다.


