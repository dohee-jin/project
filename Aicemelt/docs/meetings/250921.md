# 📅 2025-09-21

> **트로피칼** 프로젝트

## 🧭 오늘 작업한 주요 내용

* AI 스몰토크 주제 생성 기능 개발 (BE)
  * AI 생성 주제 중복 처리 로직 수정
  * 스케줄러 추가
  * 서비스 컴포넌트 책임 분리

## 🚩 내일 작업할 내용

* 스몰토크 프론트엔드 기능 개발 

---

## ✅ AI 스몰토크 주제 생성 기능 개발 (BE)
AI 생성 스몰토크 주제 중복 방지 로직은 아래 문서에 자세하게 기록했다.    
https://github.com/Aicemelt/Tropical-docs/blob/main/02_Architecture/AI_DuplicatePrevention_Guide.md

* **AI 생성 주제 중복 처리 로직 수정**   
중복 처리 로직에서 문제가 발생하여 로직을 수정했다.   
채팅모델로 부터 임베딩 값을 받아 오지 않고 AI 임베딩 모델에게 직접 임베딩 값을 받아오도록 변경했다.    
또한 회원가입을 완료한(활동기록이 없는) 사용자에게 보여줄 웰컴 주제 반환 로직도 추가했다.

    * AI 생성 주제 중복 처리 로직
      ```
      매일 새벽 2시 (스케줄러 실행)
      ↓
      1. 사용자의 기록 확인
        1-1. smalltalk_topic DB 조회
            ├─ 기존 주제 있음 → AI 주제 생성 개수 = 15개
            └─ 기존 주제 없음 → AI 주제 생성 개수 = 5개
        1-2. AI 요청 DTO 생성
        1-3. 활동 기록이 있는 경우 DB에 저장된 주제와 질문 추출
        ↓
      2. AI 요청
        2-1. 기존 주제가 있는 경우 추가 프롬프트 작성
        2-2. AI 요청 → 응답 확인 (JSON)
        ↓
      3. DB 저장
        3-1. AI 응답 JSON 파싱
        3-2. 생성 주제 임베딩 요청 → 응답 확인
        3-3. 사용자의 활동 기록 확인
            ├─ 활동 기록 없음 → 바로 DB 저장
            └─ 활동 기록 있음 → 유사도 검사 실행 → 저장
        ↓
      4. 유사도 검사
        새주제1 [임베딩: (0.1, 0.2, 0.3)]
            ├─ 기존주제A [임베딩: (0.1, 0.21, 0.31)] → cosine = 0.998 → 유사 → 저장X
            ├─ 기존주제B [임베딩: (0.5, 0.5, 0.5)]     → 계산 안함 (이미 유사 판단)
            └─ 기존주제C [임베딩: (0.0, 0.1, 0.2)]     → 계산 안함

        새주제2 [임베딩: (0.3, 0.1, 0.4)]
            ├─ 기존주제A [임베딩: (0.1, 0.21, 0.31)] → cosine = 0.92 → 유사 → 저장X
            ├─ 기존주제B [임베딩: (0.5, 0.5, 0.5)]     → 계산 안함
            └─ 기존주제C [임베딩: (0.0, 0.1, 0.2)]     → 계산 안함

        새주제3 [임베딩: (0.9, 0.1, 0.2)]
            ├─ 기존주제A [임베딩: (0.1, 0.21, 0.31)] → cosine = 0.72 → 유사X
            ├─ 기존주제B [임베딩: (0.5, 0.5, 0.5)]     → cosine = 0.88 → 유사 → 저장X
            └─ 기존주제C [임베딩: (0.0, 0.1, 0.2)]     → cosine = 0.45 → 유사X
            → 새주제3는 threshold 미만 → 저장O
      ```

    * embedding 모델 사용   
    open ai의 경우에는 AI 모델을 추가 결제하지 않고 임베딩 모델 사용이 가능했다.(text-embedding-3-small 모델 사용)
        * application.yml 설정
        채팅 모델 설정 아레에 임베딩 모델 사용 설정을 추가한다.
        ```
        spring: 
            ai:
                embedding:
                    options:
                    model: text-embedding-3-small  # 임베딩 모델
        ``` 

        * 의존성 주입   
        Spring AI 1.0.0-M5 버전에서 채팅 모델은 ChatClient 의존성을 주입받아 사용했지만 임베딩 모델은 EmbeddingClient가 아닌 EmbeddingModel로 의존성을 주입받는다. Model과 Client 로 다르니 주의가 필요하다.
        ```
        private final EmbeddingModel embeddingModel;
        ```

        * embedding 모델 사용 방법   
        chatClient와 다르게 embeddingModel은 embedForResponse 메소드를 통해 간편하게 embedding 요청을 보낸다.
        ```
        EmbeddingResponse res = embeddingModel.embedForResponse();
        ```
           
    * 배치 임베딩 처리
        ```
        int batchSize = 64;

        for (int i = 0; i < texts.size(); i += batchSize) {
            int end = Math.min(i + batchSize, texts.size());
            List<String> slice = texts.subList(i, end);

            EmbeddingResponse res = embeddingModel.embedForResponse(slice);
            List<Embedding> results = res.getResults(); // 입력 순서대로 반환
        }
        ```
        배치 처리(한번에 묶어서 처리)를 통해 API 호출 횟수 감소, 메모리/네트워크 부담 감소, 속도 개선이 가능하게 코드를 작성했다.

    * L2 정규화 및 코사인 유사도 검사   
    임베딩 백터를 L2 정규화 하여 코사인 유사도 계산의 안정성을 확보 했다.
        ```
        private double[] l2normalize(double[] v) {
            double sum = 0.0;
            for (double x : v) sum += x * x;
            double norm = Math.sqrt(sum);
            if (norm == 0) return v;

            double[] normalized = new double[v.length];
            for (int i = 0; i < v.length; i++) {
                normalized[i] = v[i] / norm;
            }
            return normalized;
        }
        ```
        임베딩 백터가 float로 반환되고 있어 double로 변환하는 메소드를 추가했다.
        ```
        private double[] toArray(Embedding e) {
            float[] floats = e.getOutput(); 
            double[] arr = new double[floats.length];
            for (int i = 0; i < floats.length; i++) {
                arr[i] = floats[i];  
            }
            return arr;
        }
        ```
        float로 반환된 값을 double로 변환하는 이유는 아래와 같다.
        * double은 float보다 정밀하여 유사도 검사에서 오차를 줄일 수 있다.
        * Json 직렬화시 double이 더 일반적이다.


* **AI 요청 배치 스케줄러 추가**   
이번 프로젝트에서 AI 스몰토크 주제 생성을 매일 정해진 시간에 자동으로 실행하도록 스케줄러를 구현했다. 
    * application.yml 스케줄러 설정 추가
    ```
      spring:
        schedules:
            task:
            scheduling:
                enabled: true
    ```
    * 스케줄러 코드 작성 
        * Scheduled 어노테이션을 활용해 cron 기반으로 스케줄러 실행
            * (cron = " 0/2 * * * *", zone = "Asia/Seoul") "초 분 시간 일 월 요일" 형식  
            * 기본 값은 매일 오전 9시로 설정(cron = "0 0 9 * * *)
            * 테스트 시 1~3분 단위로 변경 가능(cron = "0 0/3 * * * *)
        
        * AutomicBoolean 사용
            * 테스트 시 스케줄러가 실행되는 동안 이전 작업이 완료되지 않았는데 또 실행되는 상황 발생
            * 멀티스레드 환경에서 동시 실행을 막기 위해 compareAndSet(false, true) 로 상태 체크
            * 이전 작업이 진행 중이면 즉시 return → 중복 호출 방지
            * 스케줄러가 중첩 실행되어 새 주제가 계속 저장되지 못하는 문제 방지

        ```
        @Scheduled(cron = "0 0 9 * * *", zone = "Asia/Seoul")
        public void generateDailyTopics() {
            log.info("[SCHED] tick");

            // 이전 작업 진행 중 → 스킵
            if (!running.compareAndSet(false, true)) return;
            try {
                // 모든 유저 조회 -> 추후 활동 유저만 조회로 리펙토링
                List<User> users = userReadService.getAllUser();
                log.info("유저 조회 성공: {}", users);
                // AI 서비스에 모든 유저 전달
                smalltalkAIService.generateTopicsForMultipleUsers(users);
                log.info("AI 요청 시작");
            } finally {
                running.set(false);
            }

        }
        ```

* **웰컴 주제 반환 로직 추가**   
기존 로직에서는 회원가입 후 로그인 한 사용자는 활동기록이 없는 사용자고 AI는 하루에 한번 배치 처리되어 스몰토크 주제를 다음날에 확인이 가능하게 되어있다. 기존 로직으로는 사용자의 이탈을 유발할 수 있고 사용성이 떨어지게 된다. 개발 전에 회원가입 직후에 대한 논의가 없어 임의로 로직을 추가하여 진행했다.    
    * 사용자의 활동 기록을 확인   
    사용자의 활동기록을 확인하여 하나라도 있으면 true, 모두 없으면 false를 반환하는 메소드다.
        ```
        public boolean hasActivity(Long userId, User user) {

            boolean todo = todoRepository.existsById(userId);
            boolean bucket = bucketListRepository.existsByUser(user);
            boolean diary = diaryRepository.existsById(userId);
            boolean schedule = scheduleRepository.existsById(userId);

            return todo || bucket || diary || schedule;
        }
        ```
    
    * 사용자의 smalltalk_topic db 조회   
    사용자의 활동기록과 조회해온 db가 빈 리스트이면 웰컴 주제를 반환한다.
        ```
        if(!hasActivity && topics.isEmpty()){
            log.info("사용자: {}님의 활동이 없습니다. 웰컴 주제를 반환합니다.", user);
            return getInitialTopics();
        }
        ```
        ```
        private TopicResponse getInitialTopics() {
            List<WelcomeTopicProvider.WelcomeTopicSeed> seeds = WelcomeTopicProvider.seeds();
            List<SmallTalkTopicDto> dtoList = new ArrayList<>();

            for(int i = 0; i < seeds.size(); i++) {
                SmallTalkTopicDto dto = SmallTalkTopicDto.from(seeds.get(i), i + 1L);
                dtoList.add(dto);
            }

            return new TopicResponse(dtoList);
        }
        ```
    
    웰컴 주제의 경우 AI가 생성한 스몰토크가 아니기 때문에 db에 저장하지 않고 별도의 provider를 생성하여 하드코딩된 주제를 반환한다.
    ```
    public final class WelcomeTopicProvider {

    // new 로 호출 될 수 없게 막음 -> 객체 생성 방지, 유틸리티 형태 제공 목적
    private WelcomeTopicProvider() {}

    public static List<WelcomeTopicSeed> seeds() {
        return List.of(
                new WelcomeTopicSeed("LIFESTYLE", "주말 루틴", "주말에는 보통 뭘 하면서 쉬세요?"),
                new WelcomeTopicSeed("FOOD", "요즘 즐겨먹는 음식", "최근에 자주 먹는 음식이나 간식 있으세요?"),
                new WelcomeTopicSeed("CREATIVE", "가고싶은 여행지", "어디로 여행 가고 싶으세요?"),
                new WelcomeTopicSeed("THOUGHT", "소소한 감사", "최근에 감사하다고 느낀 순간이 있으세요?"),
                new WelcomeTopicSeed("TROPICAL", "트로피칼 캘린더 추천", "트로피칼 캘린더 써보셨나요?")
        );
    }

    public record WelcomeTopicSeed(
            String topicType,
            String topicContent,
            String exampleQuestion
    ) {};
}
    ```

* **서비스 컴포넌트 책임 분리**   
SmallTalkService 안에서 사용자 정보 조회, 사용자 활동 조회, AI 요청, 유사도 검사 등 모든 로직이 실행되고 있어 책임 분리를 진행했다.   
```
smalltalk/
└── service/
     ├── SmallTalkAIService       # AI 요청, 임베딩 유사도 검사, DB저장
     ├── SmallTalkSceduler        # AI 요청 배치 스케줄러
     ├── SmallTalkService         # 프론트엔드 <-> DB 요청 처리
     ├── UserActivityService      # 사용자의 활동기록 조회, 매핑, AI 요청 DTO 생성
     └── UserReadService          # 사용자 조회          
```

---

## 💭 9/21 일 회고   
AI 스몰토크 중복 처리 로직을 수정하고, 스케줄러, 웰컴 주제 반환, 서비스 책임 분리를 진행했다.중복 처리 과정에서 채팅 모델 대신 임베딩 모델을 직접 사용하도록 변경했고 L2 정규화를 추가하여 코사인 유사도 계산의 안정성을 확보하고 유사도 검사, DB 저장 로직이 제대로 동작됨을 확인했다. 또한 회원가입 직후 활동기록이 없는 사용자에게 웰컴 주제를 반환하는 로직을 추가하여 초기 사용성 문제도 해결했다. 아쉬운 점은 초기 사용성에 대한 부분을 개발 초기에 충분히 논의하지 못해 임의로 로직을 추가해야 했다는 점이다. 앞으로는 기능 구현 전에 사용성 및 예외 상황을 미리 검토하여, 불필요한 임시 코드 추가를 줄이는 방향으로 개선하도록 해야겠다.