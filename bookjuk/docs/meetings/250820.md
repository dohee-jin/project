# 📅 2025-08-20 회고

> **북적북적(BookJuk)** 프로젝트 마이페이지 페이징 기능 추가

## 🧭 오늘 논의한 주요 내용

* 마이페이지 참여 모임 정보 단 페이징 기능 추가
* 프로젝트 발표 문서 작성 및 산출물 정리

## 🚩 내일 작업할 내용

* 프로젝트 발표

---

## ✅ 마이페이지 참여 모임 정보 단 페이징 기능 추가 
참여 모임의 개수가 3개 이상 넘어가면 쌓인 모임 리스트 때문에 스크롤이 길어져 ux를 해치고 있었다.   
MVP 구현 완료, 버그 수정 완료 하여 페이징 처리 기능을 추가하기로 결정했다.   

![img.png](img.png)   

기존에는 마이페이지 진입했을 때 한 번의 조회로 사용자 정보 + 모임 정보 + 통계 정보를 하나의 API 로 가져오게 코드를 작성했다.   
페이지 기능 추가로 API를 사용자 정보 + 통계 정보만 조회하는 API 와 참여 모임 정보만 조회하는 API 두가지로 분리했다.   

API 분리로 명세서를 새롭게 작성했고 백엔드 코드와 프론트 엔드 코드도 수정했다.   

1. 백엔드 코드 수정
- MyPageResponseDto 수정   
참여 모임 정보를 받아오던 MeetingInfoDto 를 필드와 정적 팩토리 메소드에서 제거했다.
```
    public class MyPageResponse {
    
    
        private UserInfoDto profile;
        private StaticsInfoDto statistics;
    
    
        // 마이페이지 응답 dto로 바꾸는 정적 팩토리 메소드
        public static MyPageResponse of(UserInfoDto profile, StaticsInfoDto statistics) {
    
            return MyPageResponse.builder()
                    .profile(profile)
                    .statistics(statistics)
                    .build();
        }
    }
```
- MyPageService 비즈니스 로직 수정   
인증된 사용자 이메일 ->  사용자 찾기 -> 사용자 정보 획득 -> 사용자 id로 참여 모임을 조회해오던 로직을 페이징 처리를 위해 해당 로직에서 분리했다.   
```
    /**
     * 마이페이지 진입 정보 조회(디폴트) 로직입니다.
     * @param email - 로그인한 유저가 제시한 토큰에서 파싱한 이메일 정보
     * @return - 프론트 단에 전달할 유저 정보, 유저 모임 정보, 유저의 모임 참여, 좋아요 통계 정보를 반환합니다.
     */
    public MyPageResponse getMyPage(String email) {

        // 1. 사용자 이메일로 유저 정보 가져오기
        User user = getUserByEmail(email);

        // 조회된 유저 정보를 마이페이지 응답에 필요한 dto 로 변경
        UserInfoDto profile = UserInfoDto.from(user);


        // 3. 유저의 모임 참여, 좋아요 통계 정보를 가져오기
        Long userId = user.getId();
        Long meetingCount = meetingParticipantRepository.countMeetingByUserId(userId);
        StaticsInfoDto stats = getStatsByUserId(userId, meetingCount);

        return MyPageResponse.of(profile, stats);

    }
    
    /**
     * 사용자의 id 정보로 받은 좋아요 개수를 조회하고 참여한 리스트 개수와 함께 필요한 정보만 반환하는 메소드입니다.
     * @param id - 이메일 정보로 찾은 유저 id
     * @param count - 참여 리스트의 size
     * @return - 유저 id 정보롤 찾은 좋아요 개수와 참여 리스트의 개수를 받아 필요한 정보만 매핑한 dto
     */
    private StaticsInfoDto getStatsByUserId(Long id, Long count) {
        Long reviewCount = meetingReviewRepository.countReviewByUserId(id);
        return StaticsInfoDto.of(reviewCount, count);
    }
```
기존에는 사용자 id로 가져온 모임 정보에서 바로 모임 참여 개수를 확인 할 수 있었는데   
변경된 로직에서는 사용자 id로 모임 참여 정보 개수를 조회하게 수정했고 반환 타입도 int -> Long 으로 변경되었다.   
반환타입이 변경됨에 따라 StaticsInfoDto 의 meetingCount 타입도 Long 으로 변경되었다.   

참여 모임 정보만 조회해오는 비즈니스 로직을 새롭게 작성하였다.
```
    /**
     * 사용자의 id 정보로 참여한 미팅 정보를 가져오고 필요한 정보만 반환하는 메소드입니다.
     * @param email - 토큰 정보로 부터 가져온 사용자 식별 이메일
     * @return - 유저의 id 로 참여한 미팅 정보를 리스트로 받은 후 필요한 정보만 dto 로 매핑한 리스트
     */
    public Page<MeetingInfoDto> getMyMeetings(String email, Pageable pageable) {
        // 이메일로 사용자 정보 가져요기
        User user = getUserByEmail(email);
        Long id = user.getId();

        // 사용자 id 정보로 참여한 미팅 정보 반환
        Page<MeetingParticipant> meetingParticipants =
                meetingParticipantRepository.findMeetingsByUserId(id, pageable);

        // 반환된 페이지 리스트를 dto 로 매핑
        return meetingParticipants.map(MeetingInfoDto::from);
    }
```
- MeetingParticipantCustom, MeetingParticipantRepositoryImpl 에 필요한 메소드 추가   
controller -> service -> repository 로 페이징 처리를 위해 Pageable 객체를 전달하고   
타입도 page 타입으로 변경하였다.
```
    public interface MeetingParticipantCustom {
    
        // 미팅 id로 미팅 참여자 찾기
        List<User> findMeetingParticipantsByMeetingId(Long id);
    
        // 유저 id로 참여 미팅 리스트 반환
        Page<MeetingParticipant> findMeetingsByUserId(Long id, Pageable pageable);
    
        // 유저 id도 참여 미팅 리스트의 총 개수 반환
        Long countMeetingByUserId(Long id);
    }
    
    public class MeetingParticipantRepositoryImpl implements MeetingParticipantCustom {
      
        ...
    
        // 유저 id로 참여한 미팅 id 반환
        @Override
        public Page<MeetingParticipant> findMeetingsByUserId(Long id, Pageable pageable) {
    
            List<MeetingParticipant> contents = factory
                    .selectFrom(meetingParticipant)
                    .where(meetingParticipant.participant.id.eq(id))
                    .offset(pageable.getOffset())   // 시작 위치
                    .limit(pageable.getPageSize())  // 페이지 크기
                    .fetch();
    
            Long total = factory
                    .select(meetingParticipant.count())
                    .from(meetingParticipant)
                    .where(meetingParticipant.participant.id.eq(id))
                    .fetchOne();
    
            return new PageImpl<>(contents, pageable, total);
        }
    
        // 유저 id로 참여한 미팅의 총 개수 반환
        @Override
        public Long countMeetingByUserId(Long id) {
            return factory
                    .select(meetingParticipant.meeting.count())
                    .from(meetingParticipant)
                    .where(meetingParticipant.participant.id.eq(id))
                    .fetchOne();
        }
    
    }
```
- MyPageController 참여 모임 정보만 조회해오는 Get 요청 메소드 추가   
페이지는 0번 부터 시작 3개씩 잘라서 페이징 처리를 진행하게 작성했다.
```
    @GetMapping("/meetings")
    public ResponseEntity<?> getMyMeetings(
            @AuthenticationPrincipal String email,
            @PageableDefault(page = 0, size = 3, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable
    ) {
        Page<MeetingInfoDto> response = myPageService.getMyMeetings(email, pageable);
        return ResponseEntity.ok(ApiResponse.success("마이페이지 나의 참여 모임 정보 조회를 성공했습니다.", response));
    }
```

2. 프론트 엔드 코드 수정   
백엔드 단에서 모임 정보, 사용자 정보 + 통계 정보로 분리하여 프론트 단에서도 수정을 진행했다.   
- 더보기 버튼 추가   
```
const $loadMoreBtn = document.querySelector('.load-more-btn');
let currentPage = 0;
}
```
- 모임 정보 조회 요청 분리   
모임 정보 조회를 요청을 따로 분리했다.   
처음 마이페이지 접근시 기본으로 모임 정보를 조회해온다. 처음 조회해서 렌더링 할 때는 초기화가 필요하므로   
렌더링 함수에 서버에서 가져온 데이터와 false를 보내 초기화 후 렌더링을 진행할 수 있게 만들었다.
```
// 마이페이지 사용자 참여 모임 정보 조회
const fetchGetMyMeetings = async () => {
    const token = authHelper.getToken();
    if (!token) {
        throw new Error('인증 토큰이 없습니다.');
    }
    const res = await fetch(`${URL}/meetings`, {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });

    const result = await res.json();
    console.log(result);
    loadMyMeetings(result, false);

}
```
더보기 버튼으로 요청을 보낼 때마다 currentPage 의 값을 1씩 증가시켜 파라미터로 전달하여    
다음페이지 데이터를 조회해서 가져온다.
```
// 모임 정보 더보기
const loadMoreMeeting = async () => {
    currentPage ++;

    const token = authHelper.getToken();
    if (!token) {
        throw new Error('인증 토큰이 없습니다.');
    }
    try {
        const res = await fetch(`${URL}/meetings?page=${currentPage}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        const result = await res.json();
        loadMyMeetings(result, true);

    } catch (error) {
        console.error('더보기 로드 실패:', error);
    }

}
```
- 렌더링 진행   
서버에서 데이터를 가져와서 렌더링 함수에 전달했다.   
isLoadMore의 기본값을 false로 설정했고 더보기 버튼으로 서버에서 추가 데이터를 가져왔을 때는   
렌더링 함수에 전달할 때 true를 전달하여 초기화 없이 가져온 데이터들을 누적해서 뿌려주도록 렌더링을 진행했다.
```
const loadMyMeetings = (myMeetings, isLoadMore = false) => {

    // 1. 랜더링 전 기본 정보 초기화
    // 초기 로딩상황일떄만 초기화함
    if(!isLoadMore) {
        $meetingList.innerHTML = ` `;
    }

    // 미팅 정보
    const meetings = myMeetings.data.content || [];

    if(meetings.length === 0) {
        const $noMeeting = document.createElement('div');
        $noMeeting.innerHTML = `
            <div class="empty-state-icon">📖</div>
            <div class="empty-state-title">아직 참여한 모임이 없어요</div>
            <div class="empty-state-message">
                다양한 독서모임에 참여해보세요!<br>
                새로운 사람들과 함께 책을 읽는 즐거움을 경험할 수 있어요.
            </div>
            <button type="button" class="empty-state-button">
                모임 찾기
            </button>
        `;
        $noMeeting.className = 'empty-state';
        $meetingList.append($noMeeting);

        if ($loadMoreBtn) {
            $loadMoreBtn.style.display = 'none';
        }

    } else {
        meetings.forEach(meeting => {
            const $meetingItem = document.createElement('div');

            let roleClass = ``;
            let roleName = ``;

            let meetingStatus = ``;

            if(meeting.meetingStatus === 'RECRUITING') meetingStatus = '모집중';
            else if(meeting.meetingStatus === 'COMPLETED') meetingStatus = '종료';
            if(meeting.meetingStatus === 'CANCELLED') meetingStatus = '취소';

            if(meeting.role === 'HOST') {
                roleClass = 'role-host';
                roleName = '호스트';
            } else if((meeting.role === 'PARTICIPANT')){
                roleClass = 'role-participant';
                roleName = '참여자';
            }

            $meetingItem.innerHTML = `
                <div class="meeting-header">
                    <div class="meeting-info">
                        <div class="meeting-title">${meeting.meetingTitle}</div>
                        <div class="meeting-book">
                            <span class="book-title">${meeting.book.title}</span>
                            <span class="book-author">${meeting.book.author}</span>
                        </div>
                        <div class="meeting-meta">
                            <div class="meeting-meta-item">
                                <span>◎</span>
                                <span class="date">${formatDate(meeting.meetingTime)}</span>
                            </div>
                        </div>
                    </div>
                    <div class="meeting-status">
                        <span class="status-badge status-recruiting">${meetingStatus}</span>
                        <span class="role-badge ${roleClass}">${roleName}</span>
                    </div>
                </div>
            `;
            $meetingItem.className = 'meeting-item';
            $meetingItem.dataset.id = meeting.meetingId;
            $meetingList.append($meetingItem);
        })
        updateLoadMoreButton(myMeetings.data.last, isLoadMore);
    }
}
```
서버에서 가져온 데이터의 last 값을 받아서 updateLoadMoreButton에 전달하여 동적으로 렌더링을 진행했다.   
last는 true, false 값으로 가져온 페이지가 마지막이면 true를 반환한다.   
myMeetings.data.last = isLast로 isLast 값에 따라 버튼을 동적으로 제어하게 만들었다.
```
// 더보기 버튼 관리 함수
function updateLoadMoreButton(isLast, isLoadMore) {

    if ($loadMoreBtn) {
        $loadMoreBtn.style.display = isLast ? 'none' : 'block';
    }
```

---

## 💭 8/20 일 회고
마이페이지, 좋아요 기능의 MVP 구현, 버그 수정, 추가 기능 구현까지 완료했다.
프로젝트 주제 선정, 요구사항 명세서, ERD, 데이터베이스 설계, 백엔드 구현, 프론트엔드 구현, 발표 문서 작업까지
전체적으로 매끄럽게 진행이 잘 된 것 같다.

지난번 프로젝트와는 다르게 팀원 당 하나 이상의 기능을 구현하면서 유기적으로 모든 기능이 연결되어야 했다.
이 과정에서 프로젝트를 통해 실력도 많이 늘었고, 팀원들과 어떻게 의사소통하면 좋을지에 대해서도 많은 깨달음을 얻었다.

특히 프로젝트 초반, 주제 선정과 요구사항 명세서 작성에서 모두가 많이 헤맸지만 서로 소통하며 방향을 잡아갔다.
그 과정 속에서 ‘오프라인 독서 모임’이라는 주제에 맞는 기능이 무엇인지 합의해 나가며, 단순한 개발이 아니라
문제를 정의하고 해결하는 과정 전체를 경험할 수 있었다.

이번 경험은 단순히 기능 구현 능력을 키우는 것을 넘어, 협업 과정에서 필요한 소통 능력과 문제 해결 능력을 기를 수 있는 좋은 기회였다.
앞으로도 이번 프로젝트에서 얻은 교훈을 바탕으로, 더 나은 협업과 발전을 이뤄 나가고 싶다.