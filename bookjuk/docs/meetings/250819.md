# 📅 2025-08-19 회고

> **북적북적(BookJuk)** 프로젝트 마이페이지 프론트엔드 구현

## 🧭 오늘 논의한 주요 내용

* 타임리프와 javascript 를 활용하여 마이페이지 프로필 수정 프론트엔드 단을 구현
* 통합 테스트 후 버그 수정

## 🚩 내일 작업할 내용

* 전체 통합 테스트 후 버그 수정

---

## ✅ 마이페이지 프로필 수정 프론트엔드 구현
타임리프, javascript 를 활용해 백엔드에서 정보를 조회하고   
가져온 사용자의 프로필 정보를 뿌려주고 수정하여 다시 서버에 저장할 수 있는   
화면을 구현했다.   

프로필 화면의 경우 input file 로 파일을 입력받아 백엔드에서도 파일을 검증하지만   
프론트엔드에서도 파일을 검증할 수 있도록 코드를 작성했다. 
```
function uploadImage(e) {
    const imagePreview = document.getElementById('profileImage');
    const imageError = document.getElementById('imageError');

    // 에러 메시지 숨기기
    if (imageError) {
        imageError.style.display = 'none';
        imageError.textContent = '';
    }

    // 기존 미리보기 초기화
    if (imagePreview) {
        imagePreview.innerHTML = '';
    }

    // 파일이 선택되지 않았으면 리턴
    if (!e.target.files || !e.target.files[0]) {
        selectedImageFile = null;
        return;
    }

    const file = e.target.files[0];

    // 파일 크기 검증 (10MB)
    if (file.size > 10 * 1024 * 1024) {
        showImageError('파일 크기는 10MB 이하여야 합니다.');
        e.target.value = '';
        selectedImageFile = null;
        return;
    }

    // 파일 타입 검증
    if (!isValidImageFile(file)) {
        showImageError('JPG, JPEG, PNG, GIF, BMP, WEBP 파일만 업로드 가능합니다.');
        e.target.value = '';
        selectedImageFile = null;
        return;
    }

    // 파일 저장
    selectedImageFile = file;
    console.log("파일 업로드 완료! 미리보기를 생성합니다.")

    // 미리보기 생성
    const reader = new FileReader();
    reader.onload = function(e) {
        if (imagePreview) {
            imagePreview.innerHTML = `
                    <img src="${e.target.result}" alt="미리보기">
            `;
        }
    };
    reader.readAsDataURL(file);

}
```
프로필 수정 페이지는 프로필 수정 요청이 기존의 api 요청인 application/json 과 다르게   
multipart/formData 로 요청을 보내기 때문에 formData 를 만들어서 요청을 보내야 했다.   

폼 데이터 생성 함수
```
function createFormData() {

    const genre = document.querySelector('input[name="genre"]:checked')
    const username = document.getElementById('username');
    const introduction = document.getElementById('introduction');

    const formData = new FormData();

    const updateData = {
        username: username.value.trim(),
        preferredGenre: genre ? genre.value : null,
        introduction: introduction.value.trim()
    }


    const profileBlob = new Blob([JSON.stringify(updateData)], {
        type: 'application/json'
    });
    formData.append('profile', profileBlob);

    // 이미지 파일 추가 (imageFile part)
    if (selectedImageFile) {
        formData.append('imageFile', selectedImageFile);
    }

    return formData;
}
```
api 요청 
```
const updateMyProfile = async () => {

    try {

        // 폼 유효성 검증
        if (!validateForm()) {
            return;
        }

        const formData = createFormData();

        // JWT 토큰 가져오기
        const token = authHelper.getToken();
        if (!token) {
            throw new Error('인증 토큰이 없습니다.');
        }

        const response = await fetch(`${URL}/profile`, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${token}`
            },
            body: formData
        });

        if (response.ok) {
            const result = await response.json();
            // alert('프로필 정보가 성공적으로 수정되었습니다.');

            // 마이페이지로 다시 이동
            // alert 후 약간의 지연을 두고 이동
            setTimeout(() => {
                goToMyPage();
                // window.location.href = '/mypage';
            }, 100);

        } else {
            // 에러 응답 처리
            await handleErrorResponse(response);
        }

    } catch (e) {
        console.error('프로필 정보 수정에 실패했습니다.:', e);

    } finally {

    }
}
```
수정 요청의 경우 버튼 클릭 시 요청되도록 버튼에 이벤트 핸들러를 바인딩하여   
백엔드로 요청을 보내게 했다.
```
$saveBtn.addEventListener('click', e => {
    e.preventDefault();
    if(confirm('프로필 정보를 수정하시겠습니까?')) {
        updateMyProfile();
    }
})
```
그 외에 사용자 이름, 선호 장르, 자기 소개의 경우   
사용자 이름은 필수 값으로 null 이 되지 않도록 입력값을 검증했다.
```
function validateForm() {
    const username = document.getElementById('username').value.trim();

    if (!username) {
        alert('사용자명을 입력해주세요.');
        return false;
    }

    return true;
}
```

선호 장르의 경우 렌더링 시 input radio 로 되어 있는 여러 선호장르 태그들을
querySelectAll 로 다 잡아와 배열에 넣고 배열을 forEach 로 돌려 서버에서 가져온   
preferredGenre 와 같으면 .checked 가 붙게 만들었다.
```
genres.forEach(genre => {
        genre.checked = (genre.value === preferredGenre && preferredGenre !== null);
    });
```
서버에 수정 요청을 보낼때는 genre 가 checked 인 input 태그를 가져와 value 값을 변수에 넣어 보냈다.
```
const genre = document.querySelector('input[name="genre"]:checked')
```

---

## 🚨 트러블 슈팅
### 문제1: 프로필 수정 후 프로필 수정 페이지 재진입시 수정 내용 반영 오류 문제
- 원인: 로컬스토리지에 수정된 사용자 정보가 반영되지 않음
- 해결: 프로필 수정 페이지 진입 시 로컬스토리지로 부터 읽어오던 정보를 서버로부터 받아와 렌더링 하는 방식으로 수정.   
마이페이지 초기 진입시 사용자 정보를 가져오는 api 를 호출하고 해당 api 로 부터 받아오는 정보 중   
사용자 프로필 정보만 추출하여 렌더링에 사용했다. 서버에서 정보를 받아오니까 수정된 내용도 잘 반영되는 것을 확인할 수 있었다.

---

### 문제2: 커스텀 프로필 이미지 → 기본 프로필 전환 불가
- 원인: 프론트 단에서 이미지를 선택하지 않거나 기본 프로필로 전환 시 null 이 전송되어 DB에 저장되는 이미지 값이 없음.   
- 해결: 백엔드 단에서 null 일 경우 기본 프로필 이미지 URL(/images/defaultProfile.png)을 저장하도록 수정.
```
if(newImage == null) {
    newImage = "/images/defaultProfile.png";
}
user.updateProfile(request, newImage);

// 4. 수정된 유저정보 업데이트
User updatedUser = userRepository.save(user);
return UpdateProfileResponse.from(updatedUser);
```
- 추가 개선: 프론트 단에서 커스텀 프로필 이미지를 기본 프로필로 바꿀 때 새로운 이미지를 업로드해야만 삭제 버튼이 노출되는 불편이 있었다.   
사용자 프로필 이미지가 기본 프로필인지 확인하는 함수를 만들어, 커스텀 프로필일 경우에만 수정 페이지 진입 시 삭제 버튼이 자동으로 보이도록 개선하였다.  
```
// 디폴트 이미지 여부 확인
function isDefaultImage(storedImage) {
    if(storedImage !== DEFAULT_IMAGE_PATHS) return true;
}

// 이미지 삭제 버튼 노출
storedImage = user.profileImage;
if(isDefaultImage(storedImage)) {
    $removeImageBtn.style.display = 'block';
}
```


## 💭 8/19 일 회고
오늘은 마이페이지 프로필 수정 프론트엔드 구현을 완료하였다.
타임리프와 JavaScript 를 활용해 서버에서 내려준 사용자 정보를 화면에 표시하고   
수정된 내용을 다시 서버로 전송하는 흐름을 구현하였다.

트러블슈팅 과정에서, 프로필 수정 후 다시 페이지에 진입하면 이전 정보가 그대로 표시되는 문제가 있었다.   
처음에 토큰 값으로만 정보를 가져오도록 구현했기 때문에 발생한 문제였으며,   
이를 마이페이지처럼 진입 시 사용자 프로필 정보를 가져오는 api 를 별도로 만들어 해결하였다.

또한 프로필 이미지를 커스텀 프로필로 수정하는 기능뿐 아니라,   
다시 기본 프로필로 되돌릴 수 있는 기능도 추가하였다.